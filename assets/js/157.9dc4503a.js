(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{554:function(e,t,r){"use strict";r.r(t);var v=r(6),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),r("h2",{attrs:{id:"_1-vdom的优势？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-vdom的优势？"}},[e._v("#")]),e._v(" 1. VDom的优势？")]),e._v(" "),r("p",[e._v("核心还是利用利用虚拟dom，最小化dom更新，因为频繁dom更新的代价是巨大的。")]),e._v(" "),r("p",[e._v("因为"),r("code",[e._v("dom是在渲染引擎中，而js是在js V8引擎中，两者通信代价比较高")]),e._v("。\n"),r("code",[e._v("js引擎只负责 JavaScript 代码的解释与执行")]),e._v("，只是把js代码转换为字节码，然后执行（js引擎有几个好助手：编译器和作用域。"),r("a",{attrs:{href:"https://lq782655835.github.io/blogs/read-books/book-you-dont-know-javascript.html#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86",target:"_blank",rel:"noopener noreferrer"}},[e._v("编译原理"),r("OutboundLink")],1),e._v("）。\n换句话说，JS引擎本身没有时间的概念，只是一个按需执行js任意代码片段的环境。")]),e._v(" "),r("h2",{attrs:{id:"_2-vue-的模板如何被渲染成-html-以及渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-的模板如何被渲染成-html-以及渲染过程"}},[e._v("#")]),e._v(" 2. Vue 的模板如何被渲染成 HTML? 以及渲染过程?")]),e._v(" "),r("p",[r("code",[e._v("模板 -> render函数（编译） -> 返回vnode(虚拟dom关键) -> vnode patch方法进行diff -> Dom更新")])]),e._v(" "),r("h3",{attrs:{id:"vue-的整个实现流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-的整个实现流程"}},[e._v("#")]),e._v(" Vue 的整个实现流程")]),e._v(" "),r("ol",[r("li",[e._v("先把模板解析成 render 函数，把模板中的属性去变成 js 中的变量，vif,vshow,vfor 等指令变成 js 中的逻辑")]),e._v(" "),r("li",[e._v("执行 render 函数，在初次渲染执行 render 函数的过程中 绑定属性监听，收集依赖，最终得到 vNode，利用 vNode 的 Patch 方法，把 vNode 渲染成真实的 DOM")]),e._v(" "),r("li",[e._v("在属性更新后，重新执行 render 函数，不过这个时候就不需要绑定属性和收集依赖了，最终生成新的 vNode")]),e._v(" "),r("li",[e._v("把新的 vNode 和 旧的 vNode 去做对比，找出真正需要更新的 DOM，渲染在浏览器。")])]),e._v(" "),r("h2",{attrs:{id:"_3-vue双向数据绑定原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue双向数据绑定原理"}},[e._v("#")]),e._v(" 3. Vue双向数据绑定原理")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://lq782655835.github.io/blogs/vue/vue-code-0.frame.html#%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue核心XMind"),r("OutboundLink")],1)]),e._v(" "),r("ol",[r("li",[e._v("首先是vm=new Vue(options)初始化，Vue 初始化主要就干了几件事情：\n"),r("ul",[r("li",[e._v("编译template为render函数")]),e._v(" "),r("li",[e._v("合并配置")]),e._v(" "),r("li",[e._v("data深度监听（get/set），每个字段都有一个Dep对象进行Watcher管理（比如通常有1个渲染Watcher，多个Computed Watcher\n）")]),e._v(" "),r("li",[e._v("挂载一些方法到Vue.prototype上")])])]),e._v(" "),r("li",[e._v("vm.$mount(el) 触发收集 && vdom diff渲染真实DOM\n"),r("ol",[r("li",[e._v("触发收集\n"),r("ul",[r("li",[e._v("new Watcher()，新建一个渲染Watcher（watcher可以看作回调函数，当data属性改变时，对应的唯一Dep中的Watcher批量更新），将该渲染Watcher绑定到依赖的字段中（template模板中可以知道）")]),e._v(" "),r("li",[e._v("如何知道渲染Watcher依赖的字段？答案：vm.render()。render()方法中会去访问字段（get拦截方法触发，对Dep收集Watcher）。")])])]),e._v(" "),r("li",[e._v("vdom diff\n"),r("ol",[r("li",[e._v("vnode = vm.render() 拿到vnode")]),e._v(" "),r("li",[e._v("vm.update(vnode) diff算法比对，更新dom")])])])])])]),e._v(" "),r("p",[e._v("以下是双向数据绑定示意图：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/30/16586a0d1261a7b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"_4-为什么组件只能挂一个root标签？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么组件只能挂一个root标签？"}},[e._v("#")]),e._v(" 4. 为什么组件只能挂一个root标签？")]),e._v(" "),r("p",[r("code",[e._v("取决于diff算法的编写方式")]),e._v("。")]),e._v(" "),r("p",[e._v("diff算法（负责将当前的VDOM与旧的VDOM进行比较，并将差异修补到真实DOM中）依赖于以下事实：子组件的每个VNode在真实dom中都具有单个匹配的html元素。")]),e._v(" "),r("p",[e._v("比如：render: h('div', attr, children)会生成VNode（树状数据结构），然后才比较好diff。\n如果组件作为最外层的warpper，最终会解析成更细力度的子组件，知道没有组件包装。")]),e._v(" "),r("p",[e._v("参考：https://github.com/vuejs/vue/issues/7088#issuecomment-357899727")]),e._v(" "),r("h2",{attrs:{id:"_5-vue-slot原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-slot原理"}},[e._v("#")]),e._v(" 5. Vue Slot原理")]),e._v(" "),r("p",[r("RouterLink",{attrs:{to:"/temp/vue-code-slot.html"}},[e._v("Vue slot源码解析")])],1),e._v(" "),r("p",[r("code",[e._v("slot本质是把app父组件生成的vnode/function，延迟到layout子组件渲染。")])]),e._v(" "),r("h2",{attrs:{id:"_6-vuex原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-vuex原理"}},[e._v("#")]),e._v(" 6. Vuex原理")]),e._v(" "),r("p",[e._v("只关注核心Store，不考虑namespace以及mapGetter等辅助方法。")]),e._v(" "),r("p",[e._v("其实核心原理代码非常简单，就是"),r("code",[e._v("利用全局的new Vue({ data: { state }})来实现。即把组件的共享状态抽取出来，放在一个全局单例模式下管理。")])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/lq782655835/build-your-own-vuex",target:"_blank",rel:"noopener noreferrer"}},[e._v("动手实现一个Vuex"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"_7-vue-router原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-router原理"}},[e._v("#")]),e._v(" 7. Vue-Router原理")]),e._v(" "),r("ul",[r("li",[e._v("hash：onhashchanged")]),e._v(" "),r("li",[e._v("history：history.pushState")])]),e._v(" "),r("h2",{attrs:{id:"_8-ssr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-ssr"}},[e._v("#")]),e._v(" 8. SSR")]),e._v(" "),r("ul",[r("li",[e._v("服务端渲染\n服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。")]),e._v(" "),r("li",[e._v("客户端渲染html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/4/161ef7bf329e8812?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("p",[e._v("其基本实现原理：")]),e._v(" "),r("ul",[r("li",[e._v("app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。")]),e._v(" "),r("li",[e._v("webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。")]),e._v(" "),r("li",[e._v("服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。")])]),e._v(" "),r("p",[e._v("Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML。纯客户端输出过程有一个 complier 过程（「下题」中有一个简单描述），主要作用是将 template 转化成 render 字符串 。\nVue SSR 需要做的事多点（输出完整 HTML），除了 complier -> vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。")]),e._v(" "),r("h1",{attrs:{id:"react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" React")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://lq782655835.github.io/blogs/react/react-code-3.setState.html#setstate%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[e._v("React setState是异步吗"),r("OutboundLink")],1)]),e._v(" "),r("h3",{attrs:{id:"_1-react与vue异同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-react与vue异同"}},[e._v("#")]),e._v(" 1. React与Vue异同")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/6310131/78337738-0bc94100-75c4-11ea-9c1c-f484a44b48b1.png",alt:"image"}})]),e._v(" "),r("h3",{attrs:{id:"_2-生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-生命周期"}},[e._v("#")]),e._v(" 2. 生命周期")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-images.githubusercontent.com/6310131/57915545-9ed18d80-78c3-11e9-8aa5-6d1fb2cd6f63.png",alt:"image"}})]),e._v(" "),r("ul",[r("li",[e._v("创建时。将我们的组件插入到DOM中\n"),r("ul",[r("li",[e._v("constructor")]),e._v(" "),r("li",[e._v("render")]),e._v(" "),r("li",[e._v("componentDidMount")])])]),e._v(" "),r("li",[e._v("更新时\n"),r("ul",[r("li",[e._v("shouldComponentUpdate")]),e._v(" "),r("li",[e._v("render")]),e._v(" "),r("li",[e._v("componentDidUpdate")])])]),e._v(" "),r("li",[e._v("卸载时\n"),r("ul",[r("li",[e._v("componentWillunMount")])])]),e._v(" "),r("li",[e._v("废弃的三个生命周期\n"),r("ul",[r("li",[r("s",[e._v("componentWillMount")])]),e._v(" "),r("li",[r("s",[e._v("componentWillReceiveProps")])]),e._v(" "),r("li",[r("s",[e._v("componentWillUpdate")])])])]),e._v(" "),r("li",[e._v("取而代之的是两个新的生命周期函数\n"),r("ul",[r("li",[e._v("static getDerivedStateFromProps。当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps")]),e._v(" "),r("li",[e._v("getSnapshotBeforeUpdate")])])])]),e._v(" "),r("h3",{attrs:{id:"_3-immutable-js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-immutable-js"}},[e._v("#")]),e._v(" 3. immutable.js")]),e._v(" "),r("p",[e._v("Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 "),r("code",[e._v("Persistent Data Structure（持久化数据结构）")]),e._v("，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 "),r("code",[e._v("Structural Sharing（结构共享）")]),e._v("，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。")]),e._v(" "),r("p",[e._v("Immutable.js本质上是一个JavaScript的持久化数据结构的库")]),e._v(" "),r("h3",{attrs:{id:"_4-hooks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-hooks"}},[e._v("#")]),e._v(" 4. Hooks")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("hooks是什么")]),e._v(" "),r("ul",[r("li",[e._v("React Hooks是React特殊的一类函数。要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。")]),e._v(" "),r("li",[e._v("React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：\n"),r("ul",[r("li",[e._v("多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。")]),e._v(" "),r("li",[e._v("Hooks 可以引用其他 Hooks。")]),e._v(" "),r("li",[e._v("更容易将组件的 UI 与状态分离。")])])])])]),e._v(" "),r("li",[r("p",[e._v("为什么要hooks")]),e._v(" "),r("ul",[r("li",[e._v("复用有状态的组件太难。之前使用渲染属性（Render Props）和高阶组件（Higher-Order Components）复用，但层级太多")]),e._v(" "),r("li",[e._v("生命周期钩子函数里的逻辑太乱。")]),e._v(" "),r("li",[e._v("class this指向问题")])])])]),e._v(" "),r("h3",{attrs:{id:"_4-为什么要fiber（v16引入）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么要fiber（v16引入）"}},[e._v("#")]),e._v(" 4. 为什么要fiber（V16引入）")]),e._v(" "),r("p",[e._v("性能。react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。")]),e._v(" "),r("p",[e._v("React 15 及之前版本，"),r("code",[e._v("协调算法（Stack Reconciler）会一次同步处理整个组件树。它会递归遍历每个组件（虚拟DOM树），去比较新旧两颗树，得到需要更新的部分")]),e._v("。这个过程基于递归调用，一旦开始，很难去打断。也就是说，一旦工作量大，就会堵塞整个主线程（The main thread is the same as the UI thread.）。\n而事实上，我们的更新工作可能并不需要一次性全部完成，比如 offscreen 的 UI 更新并不紧急，比如 动画 需要优先完成——我们可以根据优先级调整工作，把diff过程按时间分片！")])])}),[],!1,null,null,null);t.default=a.exports}}]);