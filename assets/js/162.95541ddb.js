(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{662:function(e,v,t){"use strict";t.r(v);var _=t(9),a=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"面试篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试篇"}},[e._v("#")]),e._v(" 面试篇")]),e._v(" "),t("h3",{attrs:{id:"简历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简历"}},[e._v("#")]),e._v(" 简历")]),e._v(" "),t("blockquote",[t("p",[e._v("原则：证明自己过往经历适合该岗位。")])]),e._v(" "),t("ol",[t("li",[e._v("加公司logo")]),e._v(" "),t("li",[e._v("工作经验按照Star法则，最好有数据支撑")]),e._v(" "),t("li",[e._v("照片形象好，不是随意照+1")]),e._v(" "),t("li",[e._v("排版整洁好看+1")]),e._v(" "),t("li",[e._v("自我评价谈自己对工作的认知和看法")])]),e._v(" "),t("h3",{attrs:{id:"面试准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试准备"}},[e._v("#")]),e._v(" 面试准备")]),e._v(" "),t("ol",[t("li",[e._v("简历更新并打印")]),e._v(" "),t("li",[e._v("自我介绍准备，向朋友叙述")]),e._v(" "),t("li",[e._v("算法准备")]),e._v(" "),t("li",[e._v("智能语音业务、算法/深度学习业务\n"),t("ul",[t("li",[e._v("语音识别（产品范围无边界，较难），到语音交互（特定领域，语义理解较容易），通用场景到垂直场景。")]),e._v(" "),t("li",[e._v("深度学习：除了算法外，还需要运算。多机多卡并行运算，以及解决不同节点的通信以及传输")])])]),e._v(" "),t("li",[e._v("面试过程：STAR，（展示自信和尊重）")])]),e._v(" "),t("h3",{attrs:{id:"面试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试"}},[e._v("#")]),e._v(" 面试")]),e._v(" "),t("blockquote",[t("p",[e._v("原则：证明自己的工作能力适合这个岗位。")])]),e._v(" "),t("ol",[t("li",[e._v("回答问题时，依照STAR法则，即Situation背景，Task任务，Action行动，Result结果。")])]),e._v(" "),t("h2",{attrs:{id:"常问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常问"}},[e._v("#")]),e._v(" 常问")]),e._v(" "),t("ul",[t("li",[e._v("Promise：Promise解决了因只用回调的代码而备受困扰的控制反转问题。回调函数表达异步和并发有两个主要缺陷：缺乏顺序性和可信任性。 Promise封装了依赖时间的状态--等待底层值的完成或拒绝，所以Promise本身与时间无关。")]),e._v(" "),t("li",[e._v("闭包：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。简单说，指有权访问另一个函数作用域中的变量的函数")]),e._v(" "),t("li",[e._v("原型链：")]),e._v(" "),t("li",[e._v("this： this是指向当前上下文的一种标记，this在运行时绑定。")]),e._v(" "),t("li",[e._v("express：")]),e._v(" "),t("li",[e._v("经典\n"),t("ul",[t("li",[e._v("输入url后的步骤 --\x3e 衍生：1. 重绘和回流 2. 常用优化策略")]),e._v(" "),t("li",[e._v("commonjs和es6 module区别")]),e._v(" "),t("li",[e._v("js事件循环")]),e._v(" "),t("li",[e._v("跨域方式：跨域资源共享(Cross-origin resource sharing)")])])])]),e._v(" "),t("h3",{attrs:{id:"面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[e._v("#")]),e._v(" 面试题")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("vue3 proxy")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag",target:"_blank",rel:"noopener noreferrer"}},[e._v("Symbol.toStringTag"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("如何判断一个值是proxy （weakMap？）")])])]),e._v(" "),t("li",[t("p",[e._v("vue3最新特性")]),e._v(" "),t("ul",[t("li",[e._v("关注"),t("a",{attrs:{href:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0004-global-api-treeshaking.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue rfcs"),t("OutboundLink")],1),e._v("可知，目前已经确定的提案有4个，分别是v-slot新语法、v-slot的简写、模板动态参数以及vue全局api应用treeshaking方式。除此之外，在issue中也有非常多的正在讨论的题案，最重要的就是已经确定的基于函数式的组件，即Function-based Component API，表现形式是组件只有template以及setup方法，以前的data（vue3中是value）、computed，watch等参数都包裹在Vue下。其灵感来自React Hooks，使得组件更加纯粹以及更易测试。其他还有比如state、value、computed、watch、observer等底层能力开放，提供给开发者。")])])]),e._v(" "),t("li",[t("p",[e._v("react和vue的异同")]),e._v(" "),t("ul",[t("li",[e._v("相同： 都是数据驱动视图，都使用了虚拟dom，中间都有维护了一层virtual Node作为承载层，每当数据改变时，vnode根据diff算法得到最小修改，最终更新到dom上。都推荐组件化以及单向数据流。")]),e._v(" "),t("li",[e._v("不同：\n"),t("ol",[t("li",[e._v("核心思想不同，react目的是重新定义前端开发，而vue是降低开发者门槛。所以vue灵活易用，双向数据绑定，推崇template、单文件；react是函数式编程，推崇数据不可变，推崇JSX、all in js；")]),e._v(" "),t("li",[e._v("组件实现不同，源码层：vue2.0其实就是在vue模块下挂在了一些参数，对用户不透明；react就是数据就是视图，view = fn(data)，react内部维护了四大组件。所以vue使用tempalte、mixin，react使用jsx、HOC。")]),e._v(" "),t("li",[e._v("响应式原理不同，vue模板依赖自动收集，react基于状态机。当组件修改时，react是已该组件为根节点树进行更新（不管子节点是否有变化），所以react需要shouldUpdateComponent进行手动优化。")]),e._v(" "),t("li",[e._v("diff算法不同，vue基于开源snabbdom库改造，diff比较是基于双向链表，变diff边更新dom；而react基于tree对比，先进行patch操作，比较出哪些需要更新、删除等，设置标志flag，最后统一处理。（个人认为vue diff算法更优，毕竟有后发优势）")]),e._v(" "),t("li",[e._v("事件机制不同，react模拟了浏览器事件，所有事件都冒泡到document对象上，属于合成事件；而vue直接使用浏览器标准事件，绑定事件则合理使用了snabbdom库的模块插件。")])])])])]),e._v(" "),t("li",[t("p",[e._v("virtual dom有什么优势？")]),e._v(" "),t("ul",[t("li",[e._v("dom天生就慢，js运行在v8引擎中，而渲染在浏览器内核中（渲染引擎中），这就意味着频繁操作dom时，性能不快。另外操作dom会引起回流和重绘，浏览器渲染也需要时间。")]),e._v(" "),t("li",[e._v("vdom主要从框架层面，帮助我们直接减少dom操作；同时可以使用函数式的方式进行UI编程；另外由于有了vdom，ui界面可以与逻辑分离，使得可以把UI渲染到DOM之外，比如reactnative")])])]),e._v(" "),t("li",[t("p",[e._v("v-diff真的比原生操作dom更快吗？")]),e._v(" "),t("ul",[t("li",[e._v("不，基于框架的基础上才更快，框架给我们提供了屏蔽底层dom书写的方式，减少频繁的整更新dom同时，也使得数据驱动视图")])])]),e._v(" "),t("li",[t("p",[e._v("vue响应式原理")]),e._v(" "),t("ul",[t("li",[e._v("Observer监听data，Dep对象（观察者模式）收集模板与data依赖关系。当数据变化时，Dep通知Watcher去更新视图。")])])]),e._v(" "),t("li",[t("p",[e._v("说说小程序原理")]),e._v(" "),t("ul",[t("li",[e._v("小程序底层还是Hybrid技术，微信小程序基于双模型，即视图层以及逻辑层。")])])]),e._v(" "),t("li",[t("p",[e._v("node事件模型？")]),e._v(" "),t("ul",[t("li",[e._v("宿主Libuv")]),e._v(" "),t("li",[e._v("ss\n"),t("ol",[t("li",[e._v("timers: 执行setTimeout() 和 setInterval() 预先设定的回调函数。")]),e._v(" "),t("li",[e._v("I/O callbacks: 大部分执行都是timers 阶段或是setImmediate() 预先设定的并且出现异常的回调函数事件。")]),e._v(" "),t("li",[e._v("idle, prepare: nodejs 内部函数调用。")]),e._v(" "),t("li",[e._v("poll: 搜寻I/O事件，nodejs进程在这个阶段会选择在该阶段适当的阻塞一段时间。")]),e._v(" "),t("li",[e._v("check: setImmediate() 函数会在这个阶段执行。")]),e._v(" "),t("li",[e._v("close callbacks: 执行一些诸如关闭事件的回调函数，如socket.on('close', ...) 。")])])])])]),e._v(" "),t("li",[t("p",[e._v("node自动启动多个进程- cluster模块？")]),e._v(" "),t("ul",[t("li",[e._v("Master节点和Worker节点")]),e._v(" "),t("li",[e._v("节点间使用postmessage通信")])])]),e._v(" "),t("li",[t("p",[e._v("K8s")]),e._v(" "),t("ul",[t("li",[e._v("打包优化\n"),t("ol",[t("li",[e._v("Docker优化：使用stage、使用小的基础包")]),e._v(" "),t("li",[e._v("Webpack使用HappyPack加速、使用DLLPlugin（vendor配置分割module）")])])])])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/d6e0ab2fed25",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack DLLPlugin"),t("OutboundLink")],1),e._v("实现原理")]),e._v(" "),t("ol",[t("li",[e._v("根据vendor作为entry，生成一份vendor文件，一份mainfest.json文件")]),e._v(" "),t("li",[e._v("将manifest的文件依赖，以external形式打包")])])])]),e._v(" "),t("h3",{attrs:{id:"回答提问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回答提问"}},[e._v("#")]),e._v(" 回答提问")]),e._v(" "),t("p",[e._v("Why do you want to leave your current/last company?")]),e._v(" "),t("ol",[t("li",[e._v("业务体量 2. 技术层面 3. 成长速度")])]),e._v(" "),t("p",[e._v("提问：\n尽量围绕你的岗位进行提问,这可以使得你更快得熟悉你的工作内容,也让面试官看到你对此岗位的兴趣和热情,重要的是这些问题对于面试官而言既可以简略回答,也可以详细的给你讲解,如果他很热情得跟你介绍此岗位相关的情况,说明你可能表现得不错,否则的话,你可能不在他的备选名单里,这个时候就需要你早做打算了.")]),e._v(" "),t("ul",[t("li",[e._v("您怎么平衡业务开发以及技术追求？")]),e._v(" "),t("li",[e._v("能说下您团队的工程师文化吗？")]),e._v(" "),t("li",[e._v("能说下目前您团队所面临的技术挑战？")]),e._v(" "),t("li",[e._v("您做过最复杂的技术？")]),e._v(" "),t("li",[e._v("您从这获得的最大收获是什么？")]),e._v(" "),t("li",[e._v("在这公司有什么独一无二的工作感受？")]),e._v(" "),t("li",[e._v("对于这份工作，您有什么期望？")]),e._v(" "),t("li",[e._v("你对这个职位理想人选的要求是什么?")])]),e._v(" "),t("h3",{attrs:{id:"常归回答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常归回答"}},[e._v("#")]),e._v(" 常归回答")]),e._v(" "),t("ol",[t("li",[e._v("为什么离职： 职业生涯瓶颈")]),e._v(" "),t("li",[e._v("推荐简历生成网站：https://www.wondercv.com")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://yangshun.github.io/tech-interview-handbook/questions-to-ask",target:"_blank",rel:"noopener noreferrer"}},[e._v("tech-interview-handbook"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://github.com/Advanced-Interview-Question/front-end-interview/blob/master/docs/guide/resume.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试官到底想看什么样的简历？"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("技术栈准备\nJavaScript基础")]),e._v(" "),t("p",[e._v("JavaScript基础可以推荐《JavaScript权威指南》、《你不知道的JavaScript》通读一两遍，可以好的梳理所学知识，知识点包括\njs类型、typeof、instanceof，类型转换\n作用域与作用域链、变量提升\njs原型链、new、继承方式\nthis指向、闭包、垃圾回收机制\n事件队列、事件循环\nDOM对象\n事件委托、DOM事件模型\n原生ajax\nHtml5+CSS3")]),e._v(" "),t("p",[e._v("html5新特性、语义化\n浏览器渲染机制、重绘、重排\ncss盒子模型、flex、动画\ncss样式优先级\nBFC\nVue")]),e._v(" "),t("p",[e._v("这里只列举MVVM框架中的vue\nvue基础")]),e._v(" "),t("p",[e._v("vue生命周期、keep-alive\ncomputed与watch\nv-for中key的作用\nvue组件的通信方式\n指令\nvue底层原理")]),e._v(" "),t("p",[e._v("双向绑定实现原理\nv-model的实现\nnextTick的实现\nvnode的理解，compiler和patch的过程\nnew Vue后整个的流程\nkeep-alive的实现\nvuex、vue-router实现原理\nHttp")]),e._v(" "),t("p",[e._v("http特性以及状态码\nhttp的三次握手\nhttp1.0、http1.1、http2.0的区别\nhttp如何实现缓存\nhttps的握手过程\n输入url后http请求的完整过程\nget与post请求区别\nweb安全")]),e._v(" "),t("p",[e._v("理解xss，csrf，ddos攻击原理以及避免方式\nxss与csrf的区别\n前端工程化")]),e._v(" "),t("p",[e._v("webpack配置，webpack4.0有哪些优化点\nwebpack如何实现代码分离\n如何实现一个webpack loader\nnpm包是如何实现按需引入\n从0到1配置工程\n前端模块化，CMD、AMD、CommonJS、ESM\n前端性能优化")]),e._v(" "),t("p",[e._v("前端性能优化的几种方式\n如何做性能优化上报\n如何实现一个错误监控系统\n什么是同源策略\n前后端如何通信\n跨域通信的几种方式\n算法")]),e._v(" "),t("p",[e._v("排序")])])}),[],!1,null,null,null);v.default=a.exports}}]);